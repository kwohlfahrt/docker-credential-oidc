#!/usr/bin/env python3

import sys
import ssl
import secrets
import hashlib
import webbrowser
import json
from base64 import urlsafe_b64encode
from functools import cached_property
from dataclasses import dataclass
from threading import Thread
from queue import Queue
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.request import urlopen
from urllib.error import HTTPError
from urllib.parse import urlparse, urlunparse, urlencode, parse_qs

ssl_ctx = ssl.create_default_context()

# FIXME: This is for testing, remove
ssl_ctx.check_hostname = False
ssl_ctx.verify_mode = ssl.CERT_NONE


def parse_prefix(s, prefix):
    if not s.startswith(prefix):
        raise ValueError(f"Expected string starting with {prefix}, got {s}")
    return s[len(prefix):]


@dataclass
class AuthInfo:
    realm: str
    service: str
    scope: str | None = None

    @classmethod
    def for_registry(cls, registry):
        try:
            f = urlopen(f"https://{registry}/v2/", context=ssl_ctx)
        except HTTPError as e:
            if e.code != 401:
                raise e
            auth = e.headers["www-authenticate"]
        else:
            raise RuntimeError(f"Got {f.code} response, expected 401")

        auth = parse_prefix(auth, "Bearer ")
        challenges = auth.split(",")
        kwargs = {k: v.strip('"') for k, v in (c.split("=", maxsplit=1) for c in challenges)}
        return cls(**kwargs)

    @cached_property
    def openid_configuration(self):
        realm = urlparse(self.realm)
        path, _ = realm.path.rsplit("/", maxsplit=1)
        url = realm._replace(path="/".join([path, ".well-known", "openid-configuration"]))
        with urlopen(urlunparse(url), context=ssl_ctx) as f:
            return json.load(f)

    @property
    def auth_url(self):
        return urlparse(self.openid_configuration["authorization_endpoint"])

    @property
    def token_url(self):
        return urlparse(self.openid_configuration["token_endpoint"])


class Server(HTTPServer):
    def __init__(self, payload, queue, *args, **kwargs):
        self.payload = payload
        self.queue = queue
        self.code_verifier = secrets.token_urlsafe(32).encode().rstrip(b"=")
        self.code_challenge = urlsafe_b64encode(hashlib.sha256(self.code_verifier).digest()).rstrip(b"=")
        super().__init__(*args, **kwargs)


class Handler(BaseHTTPRequestHandler):
    def do_GET(self):
        path = urlparse(self.path)
        redirect = f"http://localhost:{self.server.server_port}/callback"

        if path.path == "/start":
            self.send_response(302)
            query = {
                'client_id': self.server.payload.service,
                'response_type': 'code',
                'redirect_uri': redirect,
                'code_challenge': self.server.code_challenge,
                'code_challenge_method': "S256",
            }
            url = self.server.payload.auth_url._replace(query=urlencode(query))
            self.send_header("Location", urlunparse(url))
            self.end_headers()
        elif path.path == "/callback":
            query = parse_qs(path.query)
            [code] = query["code"]

            data = urlencode({
                'client_id': self.server.payload.service,
                'code': code,
                'code_verifier': self.server.code_verifier,
                'grant_type': 'authorization_code',
                'redirect_uri': redirect,
            }).encode()

            with urlopen(urlunparse(self.server.payload.token_url), data=data, context=ssl_ctx) as f:
                token = json.loads(f.read())

            self.send_response(200)
            self.end_headers()
            self.wfile.write(f"Successfully authenticated to {self.server.payload}! You may close this window.".encode())

            self.server.queue.put(token)
        else:
            raise ValueError(f"Unrecognized path: {path}")

    def log_message(self, *args, **kwargs):
        return


def main(argv=None) -> int:
    if argv is None:
        argv = sys.argv[1:]

    if argv[0] != "get":
        raise RuntimeError(f"Unsupported operation {argv[1]}, expected 'get'")
    payload = sys.stdin.read().rstrip("\n")
    auth_info = AuthInfo.for_registry(payload)

    queue = Queue()
    httpd = Server(auth_info, queue, ('localhost', 8000), Handler)

    t = Thread(target=httpd.serve_forever)
    t.start()
    webbrowser.open(f"http://localhost:{httpd.server_port}/start")
    auth = queue.get()
    httpd.shutdown()
    t.join()
    json.dump({"ServerURL": payload, "Username": "OIDC", "Secret": auth["access_token"]}, sys.stdout)
    return 0

if __name__ == "__main__":
    sys.exit(main())
