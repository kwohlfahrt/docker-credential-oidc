#!/usr/bin/env python3

import sys
import ssl
import secrets
import hashlib
import webbrowser
from base64 import urlsafe_b64encode
from typing import NamedTuple
from threading import Thread, Event
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.request import urlopen
from urllib.error import HTTPError
from urllib.parse import urlparse, urlunparse, urlencode

ssl_ctx = ssl.create_default_context()

# FIXME: This is for testing, remove
ssl_ctx.check_hostname = False
ssl_ctx.verify_mode = ssl.CERT_NONE


def parse_prefix(s, prefix):
    if not s.startswith(prefix):
        raise ValueError(f"Expected string starting with {prefix}, got {s}")
    return s[len(prefix):]


class AuthInfo(NamedTuple):
    realm: str
    service: str
    scope: str | None = None

    @classmethod
    def for_registry(cls, registry):
        try:
            f = urlopen(f"https://{registry}/v2/", context=ssl_ctx)
        except HTTPError as e:
            if e.code != 401:
                raise e
            auth = e.headers["www-authenticate"]
        else:
            raise RuntimeError(f"Got {f.code} response, expected 401")

        auth = parse_prefix(auth, "Bearer ")
        challenges = auth.split(",")
        kwargs = {k: v.strip('"') for k, v in (c.split("=", maxsplit=1) for c in challenges)}
        return cls(**kwargs)


    def auth_url(self, redirect, challenge):
        realm = urlparse(self.realm)
        path, _ = realm.path.rsplit("/", maxsplit=1)
        query = {
            'client_id': 'docker',
            'response_type': 'code',
            'redirect_uri': redirect,
            'code_challenge': challenge,
            'code_challenge_method': "S256",
        }
        url = realm._replace(path="/".join([path, "auth"]), query=urlencode(query))
        return urlunparse(url)


class Server(HTTPServer):
    def __init__(self, payload, event, *args, **kwargs):
        self.payload = payload
        self.event = event
        self.code_verifier = secrets.token_urlsafe(32).encode().rstrip(b"=")
        self.code_challenge = urlsafe_b64encode(hashlib.sha256(self.code_verifier).digest()).rstrip(b"=")
        super().__init__(*args, **kwargs)


class Handler(BaseHTTPRequestHandler):
    def do_GET(self):
        path = urlparse(self.path)
        if path.path == "/start":
            self.send_response(302)
            redirect = f"http://{self.server.server_address[0]}:{self.server.server_address[1]}/callback"
            self.send_header("Location", self.server.payload.auth_url(redirect, self.server.code_challenge))
            self.end_headers()
        elif path.path == "/callback":
            self.send_response(200)
            self.end_headers()
            self.wfile.write(f"Successfully authenticated to {self.server.payload}! You may close this window.".encode())
            query = parse_qs(path.query)
            [code] = query["code"]
            [state] = query["session_state"]
            self.server.event.set()
        else:
            raise ValueError(f"Unrecognized path: {path}")

    def log_message(self, *args, **kwargs):
        return


def main(argv=None):
    if argv is None:
        argv = sys.argv[1:]

    if argv[0] != "get":
        raise RuntimeError(f"Unsupported operation {argv[1]}, expected 'get'")
    payload = sys.stdin.read().rstrip("\n")

    auth_info = AuthInfo.for_registry(payload)
    event = Event()
    httpd = Server(auth_info, event, ('localhost', 8000), Handler)

    t = Thread(target=httpd.serve_forever)
    t.start()
    webbrowser.open(f"http://{httpd.server_address[0]}:{httpd.server_address[1]}/start")
    event.wait()
    httpd.shutdown()
    t.join()

if __name__ == "__main__":
    main()
